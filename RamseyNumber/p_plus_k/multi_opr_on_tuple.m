% multi_opr_on_tuple(): performs E and F repeatedly (EFEF... or FEFE...)                     
% Input: tuple to act on
%        r -- order of graph (p+2)
%        map -- from tuple to representative tuple
% Output: array of tuples generated by multiple E's and F's
% WARNING: All input of tuples are in normal form!
function result = multi_opr_on_tuple(tuple,r,map)
odd_op = '';
even_op = '';
old_list = {};
new_list = {};
new_list{end+1} = tuple;
p = r-3;
% assign sequence of operations depending on x = (0/1)
% Reminder: E changes monochromatic "1" to "0", F changes "0" to "1"
if tuple(1) == 1
    odd_op = 'E';
    even_op = 'F';
else
    odd_op = 'F';
    even_op = 'E';
end
% until no new elements are generated (temp_list is empty)
for i = 1:intmax
    temp_list = {};
    % adding operation result to temp list
    for j = 1:length(new_list)
        cur_tuple = new_list{j};       
        if mod(i,2) ~= 0
            temp_list = [temp_list, gen_opr_on_tuple(cur_tuple,odd_op,p,r,map)];
        else
            temp_list = [temp_list, gen_opr_on_tuple(cur_tuple,even_op,p,r,map)];
        end
    end
    % eleminate duplicates in temp_list
    str = unique(cellfun(@mat2str,temp_list,'UniformOutput',false));
    temp_list = cellfun(@eval,str,'UniformOutput',false);
    % eleminate duplicates between temp and previous lists
    temp_str = cellfun(@mat2str,temp_list,'UniformOutput',false);
    old_new_str = cellfun(@mat2str,[old_list,new_list],'UniformOutput',false);
    temp_str = setdiff(temp_str,old_new_str);
    temp_list = cellfun(@eval,temp_str,'UniformOutput',false);
    % reassign lists
    old_list = [old_list, new_list];
    new_list = temp_list;
    % if no new elements generated, terminate
    if isempty(temp_list)
        result = old_list;
        break;
    end
end
end